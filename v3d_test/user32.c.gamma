/**
 * user32.c
 *
 * Author: Kenta Ishii
 * License: MIT
 * License URL: https://opensource.org/licenses/MIT
 *
 */

#include "system32.h"
#include "system32.c"

extern obj DATA_V3D_BLENDER;
extern uint32 DATA_V3D_BLENDER_SIZE;

int32 _user_start() {
	_GPUMemory *dst_img;
	_GPUMemory *dst_z;
	_GPUMemory *src_img;
	_GPUMemory *src_z;
	_GPUMemory *uniforms;
	_FragmentShader *fragmentshader;
	uint32 *jobs;
	uint32 result;

	_control_qpul2cache( 0b101 );
	_clear_qpucache( 0x0F0F0F0F );

	dst_img = (_GPUMemory*)heap32_malloc( _wordsizeof( _GPUMemory ) );
	_gpumemory_init( dst_img, 256, 16, 0xC );
	dst_z = (_GPUMemory*)heap32_malloc( _wordsizeof( _GPUMemory ) );
	_gpumemory_init( dst_z, 256, 16, 0xC );
	src_img = (_GPUMemory*)heap32_malloc( _wordsizeof( _GPUMemory ) );
	_gpumemory_init( src_img, 256, 16, 0xC );
	src_z = (_GPUMemory*)heap32_malloc( _wordsizeof( _GPUMemory ) );
	_gpumemory_init( src_z, 256, 16, 0xC );
	uniforms = (_GPUMemory*)heap32_malloc( _wordsizeof( _GPUMemory ) );
	_gpumemory_init( uniforms, 32, 16, 0xC );
	fragmentshader = (_FragmentShader*)heap32_malloc( _wordsizeof( _FragmentShader ) );
	_fragmentshader_init( fragmentshader, DATA_V3D_BLENDER, DATA_V3D_BLENDER_SIZE );

	dst_img->arm[0].u32 = 0xFF000000;
	dst_img->arm[1].u32 = 0xFF000001;
	dst_img->arm[2].u32 = 0xFF000002;
	dst_img->arm[3].u32 = 0xFF000003;
	dst_img->arm[4].u32 = 0xFF000004;
	dst_img->arm[5].u32 = 0xFF000005;
	dst_img->arm[6].u32 = 0xFF000006;
	dst_img->arm[7].u32 = 0xFF000007;
	dst_img->arm[8].u32 = 0xFF000008;
	dst_img->arm[9].u32 = 0xFF000009;
	dst_img->arm[10].u32 = 0xFF00000A;
	dst_img->arm[11].u32 = 0xFF00000B;
	dst_img->arm[12].u32 = 0xFF00000C;
	dst_img->arm[13].u32 = 0xFF00000D;
	dst_img->arm[14].u32 = 0xFF00000E;
	dst_img->arm[15].u32 = 0xFF00000F;
	dst_img->arm[16].u32 = 0xFF000010;
	dst_img->arm[17].u32 = 0xFF000011;
	dst_img->arm[18].u32 = 0xFF000012;
	dst_img->arm[19].u32 = 0xFF000013;
	dst_img->arm[20].u32 = 0xFF000014;
	dst_img->arm[21].u32 = 0xFF000015;
	dst_img->arm[22].u32 = 0xFF000016;
	dst_img->arm[23].u32 = 0xFF000017;
	dst_img->arm[24].u32 = 0xFF000018;
	dst_img->arm[25].u32 = 0xFF000019;
	dst_img->arm[26].u32 = 0xFF00001A;
	dst_img->arm[27].u32 = 0xFF00001B;
	dst_img->arm[28].u32 = 0xFF00001C;
	dst_img->arm[29].u32 = 0xFF00001D;
	dst_img->arm[30].u32 = 0xFF00001E;
	dst_img->arm[31].u32 = 0xFF00001F;

	dst_z->arm[0].u32 = 0x01;
	dst_z->arm[1].u32 = 0x01;
	dst_z->arm[2].u32 = 0x01;
	dst_z->arm[3].u32 = 0x01;
	dst_z->arm[4].u32 = 0x01;
	dst_z->arm[5].u32 = 0x01;
	dst_z->arm[6].u32 = 0x01;
	dst_z->arm[7].u32 = 0x01;
	dst_z->arm[8].u32 = 0x01;
	dst_z->arm[9].u32 = 0x01;
	dst_z->arm[10].u32 = 0x01;
	dst_z->arm[11].u32 = 0x01;
	dst_z->arm[12].u32 = 0x01;
	dst_z->arm[13].u32 = 0x01;
	dst_z->arm[14].u32 = 0x01;
	dst_z->arm[15].u32 = 0x01;
	dst_z->arm[16].u32 = 0x01;
	dst_z->arm[17].u32 = 0x01;
	dst_z->arm[18].u32 = 0x01;
	dst_z->arm[19].u32 = 0x01;
	dst_z->arm[20].u32 = 0x01;
	dst_z->arm[21].u32 = 0x01;
	dst_z->arm[22].u32 = 0x01;
	dst_z->arm[23].u32 = 0x01;
	dst_z->arm[24].u32 = 0x01;
	dst_z->arm[25].u32 = 0x01;
	dst_z->arm[26].u32 = 0x01;
	dst_z->arm[27].u32 = 0x01;
	dst_z->arm[28].u32 = 0x01;
	dst_z->arm[29].u32 = 0x01;
	dst_z->arm[30].u32 = 0x01;
	dst_z->arm[31].u32 = 0x01;

	src_img->arm[0].u32 = 0xFF000100;
	src_img->arm[1].u32 = 0xFF000101;
	src_img->arm[2].u32 = 0xFF000102;
	src_img->arm[3].u32 = 0xFF000103;
	src_img->arm[4].u32 = 0xFF000104;
	src_img->arm[5].u32 = 0xFF000105;
	src_img->arm[6].u32 = 0xFF000106;
	src_img->arm[7].u32 = 0xFF000107;
	src_img->arm[8].u32 = 0xFF000108;
	src_img->arm[9].u32 = 0xFF000109;
	src_img->arm[10].u32 = 0xFF00010A;
	src_img->arm[11].u32 = 0xFF00010B;
	src_img->arm[12].u32 = 0xFF00010C;
	src_img->arm[13].u32 = 0xFF00010D;
	src_img->arm[14].u32 = 0xFF00010E;
	src_img->arm[15].u32 = 0xFF00010F;
	src_img->arm[16].u32 = 0xFF000110;
	src_img->arm[17].u32 = 0xFF000111;
	src_img->arm[18].u32 = 0xFF000112;
	src_img->arm[19].u32 = 0xFF000113;
	src_img->arm[20].u32 = 0xFF000114;
	src_img->arm[21].u32 = 0xFF000115;
	src_img->arm[22].u32 = 0xFF000116;
	src_img->arm[23].u32 = 0xFF000117;
	src_img->arm[24].u32 = 0xFF000118;
	src_img->arm[25].u32 = 0xFF000119;
	src_img->arm[26].u32 = 0xFF00011A;
	src_img->arm[27].u32 = 0xFF00011B;
	src_img->arm[28].u32 = 0xFF00011C;
	src_img->arm[29].u32 = 0xFF00011D;
	src_img->arm[30].u32 = 0xFF00011E;
	src_img->arm[31].u32 = 0xFF00011F;

	src_z->arm[0].u32 = 0x01;
	src_z->arm[1].u32 = 0x00;
	src_z->arm[2].u32 = 0x01;
	src_z->arm[3].u32 = 0x00;
	src_z->arm[4].u32 = 0x01;
	src_z->arm[5].u32 = 0x00;
	src_z->arm[6].u32 = 0x01;
	src_z->arm[7].u32 = 0x00;
	src_z->arm[8].u32 = 0x01;
	src_z->arm[9].u32 = 0x00;
	src_z->arm[10].u32 = 0x01;
	src_z->arm[11].u32 = 0x00;
	src_z->arm[12].u32 = 0x01;
	src_z->arm[13].u32 = 0x00;
	src_z->arm[14].u32 = 0x01;
	src_z->arm[15].u32 = 0x00;
	src_z->arm[16].u32 = 0x00;
	src_z->arm[17].u32 = 0x00;
	src_z->arm[18].u32 = 0x01;
	src_z->arm[19].u32 = 0x01;
	src_z->arm[20].u32 = 0x00;
	src_z->arm[21].u32 = 0x00;
	src_z->arm[22].u32 = 0x01;
	src_z->arm[23].u32 = 0x01;
	src_z->arm[24].u32 = 0x00;
	src_z->arm[25].u32 = 0x00;
	src_z->arm[26].u32 = 0x01;
	src_z->arm[27].u32 = 0x01;
	src_z->arm[28].u32 = 0x00;
	src_z->arm[29].u32 = 0x00;
	src_z->arm[30].u32 = 0x01;
	src_z->arm[31].u32 = 0x01;

	uniforms->arm[0].u32 = dst_img->gpu;
	uniforms->arm[1].u32 = dst_z->gpu;
	uniforms->arm[2].u32 = src_img->gpu;
	uniforms->arm[3].u32 = src_z->gpu;
	uniforms->arm[4].u32 = 1;
	uniforms->arm[5].u32 = 2;
	uniforms->arm[6].u32 = 2;
	uniforms->arm[7].u32 = 2;
	jobs = (uint32*)heap32_malloc( 2 );
	jobs[0] = uniforms->gpu;
	jobs[1] = fragmentshader->gpu;
	result = _execute_qpu( 1, jobs, false, 0xFF0000 );

print32_debug( result, 0, 0 );
print32_debug_hexa( (obj)dst_img->arm, 0, 12, 256 );
print32_debug_hexa( (obj)dst_z->arm, 0, 256, 256 );

	result = _gpumemory_free( dst_img );
print32_debug( result, 0, 500 );
	result = _gpumemory_free( dst_z );
print32_debug( result, 0, 512 );
	result = _gpumemory_free( src_img );
print32_debug( result, 0, 524 );
	result = _gpumemory_free( src_z );
print32_debug( result, 0, 536 );
	result = _gpumemory_free( uniforms );
print32_debug( result, 0, 548 );
	result = _fragmentshader_free( fragmentshader );
print32_debug( result, 0, 560 );

	while( true ) {
	}
	return EXIT_SUCCESS;
}

