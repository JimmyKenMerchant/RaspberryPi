/**
 * user32.c
 *
 * Author: Kenta Ishii
 * License: MIT
 * License URL: https://opensource.org/licenses/MIT
 *
 */

#include "system32.h"
#include "system32.c"

void binary_random( uchar8* array, uint32 array_size );
void print_life( uchar8* life, uint32 life_height, uint32 life_width );

uchar8* life1;
uchar8* life2;
uchar8* life_front;
uchar8* life_back;
uint32 life_height = 32; // Multiply of 4
uint32 life_width = 32;
uint32 life_size;
bool life_switch = true;

int32 _user_start()
{
	uchar8 number_neighbor;
	uint32 offset_vertical;
	int32 neighbor_vertical;
	int32 neighbor_horizontal;

	life_size = life_height * life_width;
	life1 = (uchar8*)heap32_malloc( life_size / 4 ); // One Unit of This Malloc is One Word (4 Bytes)
	life2 = (uchar8*)heap32_malloc( life_size / 4 ); // One Unit of This Malloc is One Word (4 Bytes)

	binary_random( life1, life_size );

//print32_debug_hexa( (uint32)life1, 0, 0, life_size );
//print32_debug_hexa( (uint32)life2, 0, 300, life_size );

	print_life( life1, life_height, life_width );

	while(1) {
		if ( life_switch ) {
			life_front = life1;
			life_back = life2;
			life_switch = false;
		} else {
			life_front = life2;
			life_back = life1;
			life_switch = true;
		}
		print_life( life_front, life_height, life_width );

		for ( uint32 i = 0; i < life_height; i++ ) {
			offset_vertical = i * life_width;
			for ( uint32 j = 0; j < life_width; j++ ) {
				number_neighbor = 0;

				// Vertical Shift to Upper Neighbors
				neighbor_vertical = i - 1;
				if ( neighbor_vertical < 0 ) neighbor_vertical = life_height - 1;
				neighbor_horizontal = j - 1;
				if ( neighbor_horizontal < 0 ) neighbor_horizontal = life_width - 1;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;
				neighbor_horizontal = j;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;
				neighbor_horizontal = j + 1;
				if ( neighbor_horizontal >= life_width ) neighbor_horizontal = 0;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;

				// Vertical Shift to Horizontal Neighbors
				neighbor_vertical = i;
				neighbor_horizontal = j - 1;
				if ( neighbor_horizontal < 0 ) neighbor_horizontal = life_width - 1;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;
				neighbor_horizontal = j + 1;
				if ( neighbor_horizontal >= life_width ) neighbor_horizontal = 0;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;

				// Vertical Shift to Lower Neighbors
				neighbor_vertical = i + 1;
				if ( neighbor_vertical >= life_height ) neighbor_vertical = 0;
				neighbor_horizontal = j - 1;
				if ( neighbor_horizontal < 0 ) neighbor_horizontal = life_width - 1;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;
				neighbor_horizontal = j;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;
				neighbor_horizontal = j + 1;
				if ( neighbor_horizontal >= life_width ) neighbor_horizontal = 0;
				if ( life_front[neighbor_vertical*life_width+neighbor_horizontal] ) number_neighbor++;

				if ( number_neighbor < 2 || number_neighbor > 3 ) {
					life_back[offset_vertical+j] = 0x00;
				} else if ( number_neighbor == 3 ) { // 2 Stays Status
					life_back[offset_vertical+j] = 0xFF;
				}
				arm32_dsb();
				arm32_isb();
			}
		}

		_sleep( 500000 );
	}

	return EXIT_SUCCESS;
}

void binary_random( uchar8* array, uint32 array_size ) {
//print32_debug( (uint32)array, 0, 100 );
//print32_debug( (uint32)array_size, 0, 112 );
	for ( uint32 i = 0; i < array_size; i++ ) {
		if ( _random( 255 ) > 127) {
			array[i] = 0xFF;
		} else {
			array[i] = 0x00;
		}
//print32_debug( i, 0, 124 );
		arm32_dsb();
		arm32_isb();
	}
}

void print_life( uchar8* life, uint32 life_height, uint32 life_width ) {
	uint32 offset_vertical = 0;
	print32_set_caret( print32_string( "\x1B[H\0", FB32_X_CARET, FB32_Y_CARET, 3 ) ); // Cursor to Upper Left Corner
	for ( uint32 i = 0; i < life_height; i++ ) {
		for ( uint32 j = 0; j < life_width; j++ ) {
			print32_set_caret( print32_number( (uint32)(life[offset_vertical+j]<<24), FB32_X_CARET, FB32_Y_CARET, 2 ) );
			arm32_dsb();
			arm32_isb();
		}
		print32_set_caret( print32_string( "\n\0", FB32_X_CARET, FB32_Y_CARET, 1 ) );
		offset_vertical += life_width;
	}

}

