/**
 * user32.c
 *
 * Author: Kenta Ishii
 * License: MIT
 * License URL: https://opensource.org/licenses/MIT
 *
 */

#include "system32.h"
#include "system32.c"

void binary_random( uchar8* array, uint32 array_size );
void print_life( uchar8* life, uint32 life_height, uint32 life_width );
uint32 check_index( int32 life_index, uint32 life_size );

uint32 life_height = 32; // Multiply of 4
uint32 life_width = 32;
uint32 life_size;
bool life_switch = true;

int32 _user_start()
{

	life_size = life_height * life_width;
	uchar8* life1 = (uchar8*)heap32_malloc( life_size / 4 ); // One Unit of This Malloc is One Word (4 Bytes)
	uchar8* life2 = (uchar8*)heap32_malloc( life_size / 4 ); // One Unit of This Malloc is One Word (4 Bytes)

	binary_random( life1, life_size );

//print32_debug_hexa( (uint32)life1, 0, 0, life_size );
//print32_debug_hexa( (uint32)life2, 0, 300, life_size );

	print_life( life1, life_height, life_width );

	while(1) {
		uchar8* life_front;
		uchar8* life_back;
		if ( life_switch ) {
			life_front = life1;
			life_back = life2;
			life_switch = false;
		} else {
			life_front = life2;
			life_back = life1;
			life_switch = true;
		}
		print_life( life_front, life_height, life_width );

		for ( uint32 i = 0; i < life_size; i++ ) {
			uchar8 number_neighbor = 0;
			if ( life_front[check_index( i - life_width - 1, life_size )] ) number_neighbor++;
			if ( life_front[check_index( i - life_width, life_size )] ) number_neighbor++;
			if ( life_front[check_index( i - life_width + 1, life_size )] ) number_neighbor++;
			if ( life_front[check_index( i - 1, life_size )] ) number_neighbor++;
			if ( life_front[check_index( i + 1, life_size )] ) number_neighbor++;
			if ( life_front[check_index( i + life_width - 1, life_size )] ) number_neighbor++;
			if ( life_front[check_index( i + life_width, life_size )] ) number_neighbor++;
			if ( life_front[check_index( i + life_width + 1, life_size )] ) number_neighbor++;
			if ( number_neighbor < 2 || number_neighbor > 3 ) {
				life_back[i] = 0x00;
			} else if ( number_neighbor == 3 ) { // 2 Stays Status
				life_back[i] = 0xFF;
			}
			arm32_dsb();
			arm32_isb();
		}

		_sleep( 500000 );
	}

	return EXIT_SUCCESS;
}

void binary_random( uchar8* array, uint32 array_size ) {
//print32_debug( (uint32)array, 0, 100 );
//print32_debug( (uint32)array_size, 0, 112 );
	for ( uint32 i = 0; i < array_size; i++ ) {
		if ( _random( 255 ) > 127) {
			array[i] = 0xFF;
		} else {
			array[i] = 0x00;
		}
//print32_debug( i, 0, 124 );
		arm32_dsb();
		arm32_isb();
	}
}

void print_life( uchar8* life, uint32 life_height, uint32 life_width ) {
	uint32 offset_vertical = 0;
	print32_set_caret( print32_string( "\x1B[H\0", FB32_X_CARET, FB32_Y_CARET, 3 ) ); // Cursor to Upper Left Corner
	for ( uint32 i = 0; i < life_height; i++ ) {
		for ( uint32 j = 0; j < life_width; j++ ) {
			print32_set_caret( print32_number( (uint32)(life[offset_vertical+j]<<24), FB32_X_CARET, FB32_Y_CARET, 2 ) );
			arm32_dsb();
			arm32_isb();
		}
		print32_set_caret( print32_string( "\n\0", FB32_X_CARET, FB32_Y_CARET, 1 ) );
		offset_vertical += life_width;
	}

}

uint32 check_index( int32 life_index, uint32 life_size ) {
	if ( life_index < 0 ) {
		life_index += life_size;
	} else if ( life_index >= life_size ) {
		life_index -= life_size;
	}
	return life_index;
}

